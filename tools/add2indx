#!/bin/bash
# VERSION 7: Update for increased table elements and map.js markers & tracks
# Specify starting & default values for shell variables 
MAPFILE=0
TOM=0
indxLoc="/Users/kencowles/src/ktesa/index.html"
mapjsLoc="/Users/kencowles/src/ktesa/scripts/map.js" 
geomapLoc="/Users/kencowles/src/ktesa/maps/"
jsonLoc="/Users/kencowles/src/ktesa/json/"
# Now process command line arguments
for i
do
#	-m: get geomap name
	if [ $MAPFILE -eq 1 ]
	then {
		mapfile=$i
		mapreqd=1
		MAPFILE=2
	}
	fi
        # find flags:
        case $i in
	-T) read -p "TOM: Specify your complete filespec (include index.html) for the index page: " indxLoc
            read -p "TOM: Also specify the complete filespec (include map.js) for the map.js file: " mapjsLoc
            read -p "TOM: specify the DIRECTORY (ending with \"/\") for the geomap: " geomapLoc
	    read -p "Lastly, provide the complete filespec for the json DIRECTORY (with ending \"/\"): " jsonLoc ;;
	-m) MAPFILE=1 ;;
	-h) echo "
*** Version 7
Updated to add increased number of data elements per row of table in index.html
and added updates to map.js to accommodate marker and track creation
"
#*** Version 6
#Compatible with new Google Map index page; potentially modifies both index.html and map.js
#User can choose not to modify, but independently save local copies of modified files.
#*** Version 5
#Added checking of map file to ensure Google API key is present
#*** Version 4.1
#Rewritten to accommodate icon-based index table
#[4.1: added local check for FlckrAlbumURL created by mkgpsv]
# *** Version 3.0
# Added prompt to identify expected exposure 
# *** Version 2.0
# Added prompt to locate region of NM Map in which hike occurred
# *** Version 1.0
	echo "
This utility will prompt the user for input to create a new row in the
table of \"index.html\", and to modify the corresponding map.js file 
in order to add a marker on the map.

Inputs will be verified by the user before creating the html,
or modifying the map.js file.

TOM: Use -T flag (no arg) so that you can specify the correct filepaths to the files
(the routine will prompt you)

Use the -m flag to specify the NAME ONLY of the geomap: it is assumed that the location
of the geomap is /Users/kencowles/src/ktesa/maps or as specified by TOM
If there is no geomap (ie no -m flag), the routine will check for one, but ask if it is needed.
Example if present:   -m example_geomap_no_lists.html

The user will have the opportunity to save the file to index.html, or save only
the local copy, \"newindex.html\" if review is desired before saving to index.html;
The user similarly will have the opportunity to save the map.js file, or save only a 
local copy, \"newmap.js\".

"
	exit;;
        esac
done
if [ $MAPFILE -eq 0 ]
then {
	mapreqd=1
	good="NotOK"
	while
		[ $good != "OK" ]
	do
		echo ""
		echo "Map file not specified:"
        	read -p "Is geomap included with this web page? " map
        	case $map in
                	[nN]* ) echo "*** Google API Key not required"
				mapreqd=0
				good="OK" ;;
                	[yY]* ) echo "Google API Key is required;"
				read -p "please specify geomap name (no path): " mapfile
				good="OK" ;;
                	* ) echo "Y or N only please!";;
        	esac
	done
}
fi
if [ $mapreqd -gt 0 ]
# assert validity of geomap name
then {
        good="NotOK"
        while
	        [ $good != "OK" ]
        do
            msg=$'\nGeomap name (including file extension): '
            echo "$msg" "$mapfile"
            read -p "Is the geomap filename Correct? [Y or N]: " answer
            case $answer in
                [nN]* ) read -p "Enter correct geomap filename here: " mapfile;;
                [yY]* ) good="OK";;
                * ) echo "Y or N only please!";;
            esac
        done
	mapLoc="$geomapLoc""$mapfile"
	echo ""
	if [ -f $mapLoc ] 
	then {
		echo "File located"
		echo ""
	}
	else {
		echo "geomap file not located"
		exit
	}
	fi
	echo "The map at "${mapLoc}" will be checked for existence of the Google API Key;
    -if not present, the key will be inserted;
    You will have the opportunity to accept the change or not"
	# now process the map for the Google API Key:
	/usr/bin/awk -v sq="'" '
	{
		if( match($0,/google_api_key = /) ) {
			APIloc=index($0,"google_api_key = ") +17
			currVal=substr($0,APIloc,2)
			newStr=substr($0,1,APIloc)
			strLgth=length - APIloc
			remains=substr($0,APIloc+2,strLgth)
			key="AIzaSyA2Guo3uZxkNdAQZgWS43RO_xUsKk1gJpU"sq
			if( currVal == sq"A" ) {
				print "YOWZAH"
			}
			else {
				print newStr key remains
			}
		} else {
			print $0
		}
	}' $mapLoc > zool
	chg=`grep YOWZAH zool | wc -l`
	if [ $chg -eq 0 ] 
	then {
		good="NotOK"
		echo ""
		read -p "** API key not detected in map; Do you wish to overwrite "${mapfile}" with key? [Y/N]: " answer
		while
		        [ $good != "OK" ]
		do
		        case $answer in
		                [nN]* ) echo "No changes made" 
					good="OK" ;;
		                [yY]* ) mv zool $mapLoc
					echo "Map ["${mapfile}"] updated"
					good="OK";;
		                * ) echo "Y or N only please!";;
		        esac
		done
	}
	else {
		echo "Key already present - nothing modified"
		rm zool
	}
	fi
}
fi
echo ""
# Test for existence of index.html for the path:
if [ -f $indxLoc ] 
then
	echo "using" "$indxLoc" "as basis for potential modification..."
else
	echo "index.html file not found at" "$indxLoc"
	exit
fi
echo "The file:" "$indxLoc" "will be modified (if user opts) to add a row to the table"
fext=.html
echo ""
# in order to properly create the markers & tracks in the js file, this utility needs to know
# what "type" the hike is, as below:
echo "This routine needs to know what kind of hike to specify [CAPITAL LETTERS ONLY]:
     Type \"V\" for Park Visitor Center-based marker (i.e. index page);
     Type \"C\" for cluster hike - i.e. trailhead in very close proximity to another, or overlapping;
     Type \"H\" for \"normal\" hike - i.e. none of the above types."
read -p "Enter single letter here: " hikeType
good="NotOK"
while
        [ $good != "OK" ]
do
        msg=$'\nYou selected: '
        echo "$msg""$hikeType"
        read -p "Is this the type of marker you wish to use [Capital Letter Only]? [Y or N]: " answer
        case $answer in
                [nN]* ) read -p "Re-enter single-letter marker type [Capital Letter Only]: [V, C, H]: " hikeType ;;
                [yY]* ) good="OK" ;;
                * ) echo "Y or N only please!" ;;
        esac
        if [ $hikeType != "C" ] && [ $hikeType != "V" ] && [ $hikeType != "H" ]
        then {
                read -p "Unrecognized type; enter [cap. V, C, or H]: " hikeType
                good="NotOK"
        }
        fi
done
notindx=1
case $hikeType in
        V) hikeAR="ctrPinHikes"
	   echo "setting notindx=0"
	   notindx=0 ;;
        C) hikeAR="clusterPinHikes" ;;
        H) hikeAR="othrHikes" ;;
esac
if [ $notindx -eq 0 ]
then {
	echo "The following parameters will be pre-assigned:"
	echo "    WOW Factor: See Indx"
        echo "    Distance: 0* miles"
        echo "    Elevation: 0* ft"
        echo "    Difficulty: See Indx"
        echo "    Exposure: See Indx"
	echo "    Google Directions: See Indx"
        echo "    Flickr album entry: See Indx"
        echo "Row class will be \"indxd\""
}
fi
echo ""
read -p "Enter the name of the hike location (nearest city): " city
read -p "Enter hike name [Append with \"Index\" for Index pages]: " hike
read -p "Enter hike page (or index site) base filename [* Assumed to be in project pages dir with .html extension]: " webpg
if [ $notindx -gt 0 ]
then {
	dirs=""
	read -p "Enter WOW Factor: " wow
	read -p "Enter hike distance (round trip) in miles: " miles
	read -p "Enter hike elevation max in feet: " elev
	read -p "Enter hike difficulty: " ease
	read -p "Enter S (sunny-exposed), M (mix sun-shade), or W (well-shaded): " exp
	read -p "Enter Google Map Directions link, if known (otherwise hit RETURN): " dirs
	if [ -f FlckrAlbumURL ] 
	then
		flnk=`cat FlckrAlbumURL`
	else
		read -p "Enter hike Flickr album link (url): " flnk
	fi
}
fi
echo ""
echo "*** Check the data for accuracy before proceeding ***"
# ----------------- TEST THE INPUT DATA --------------------
good="NotOK"
while
	[ $good != "OK" ]
do
    msg=$'\nLocation: '
    echo "$msg" $city
    read -p "Is the location Correct? [Y or N]: " answer
    case $answer in
	[nN]* ) read -p "Enter correct location here: " city;;
	[yY]* ) good="OK";;
	* ) echo "Y or N only please!";;
    esac
done
good="NotOK"
while
        [ $good != "OK" ]
do
    msg=$'\nHike Name: '
    echo "$msg" $hike
    read -p "Is the hike name correct? [Y or N]: " answer
    case $answer in
        [nN]* ) read -p "Enter correct hike name here: " hike;;
        [yY]* ) good="OK";;
        * ) echo "Y or N only please!";;
    esac
done
good="NotOK"
while
	[ $good != "OK" ]
do
	msg=$'\nWeb page for hike (or index): pages/'
	echo "$msg"$webpg".html"
	read -p "Is this the correct webpage html file? [Y or N]: " answer
	case $answer in
	    [nN]* ) read -p "Enter correct web page base name [* Assumed to be in project pages dir with .html extension]: " webpg ;;
	    [yY]* ) good="OK" ;;
	    * ) echo "Y or N only please!" ;;
	esac
done
# if the entry is not an index site, prompt for the distance, elevation, ease of hike::
if [ $notindx -gt 0 ]
then {
	# WOW FACTOR:
	good="NotOK"
	while
       		 [ $good != "OK" ]
	do
    		msg=$'\nWow Factor: '
    		echo "$msg" $wow
   		read -p "Is the specified WOW Factor correct? [Y/N]: " answer
    		case $answer in
        		[nN]* ) read -p "Enter correct WOW Factor here: " wow ;;
        		[yY]* ) good="OK" ;;
        		* ) echo "Y or N only pleas!" ;;
    		esac
	done
	# DISTANCE:
	good="NotOK"
	while
	        [ $good != "OK" ]
	do
	    msg=$'\nDistance (miles): '
	    echo "$msg" $miles
	    read -p "Is the distance in miles correct? [Y or N]: " answer
	    case $answer in
	        [nN]* ) read -p "Enter correct distance here (miles): " miles;;
	        [yY]* ) good="OK";;
	        * ) echo "Y or N only please!";;
	    esac
	done
	good="NotOK"
	# ELEVATION:
	while
       	 [ $good != "OK" ]
	do
	    msg=$'\nElevation (feet): '
	    echo "$msg" $elev
	    read -p "Is the elevation in feet correct? [Y or N]: " answer
	    case $answer in
	        [nN]* ) read -p "Enter correct elevation in feet here: " elev;;
	        [yY]* ) good="OK";;
	        * ) echo "Y or N only please!";;
	    esac
	done
	good="NotOK"
	# EASE OF HIKE:
	while
       	 [ $good != "OK" ]
	do
	    msg=$'\nEase of hike: '
	    echo "$msg" $ease
	    read -p "Is the ease-of-hike rating correct? [Y or N]: " answer
	    case $answer in
	        [nN]* ) read -p "Enter correct ease-of-hike rating here: " ease;;
	        [yY]* ) good="OK";;
	        * ) echo "Y or N only please!";;
	    esac
	done
	good="NotOK"
	# EXPOSURE RATING:
	# FIRST: check exposure rating;
	case $exp in
	    [mMsSwW] ) setting="OK" ;;
	    * ) setting="notOK" ;;
	esac
	# if the setting was incorrect to begin with, get a legitimate one:
	if [ $setting != OK ]
	then
	    while [ $setting != OK ]
	    do
		echo ""
	        echo "Exposure factor is incorrectly set to" "$exp"
	        read -p "Enter S (sunny-exposed), M (mix sun-shade), or W (well-shaded) only: " exp
		case $exp in
		    [mMsSwW] ) setting="OK" ;;
		    * )  setting="notOK" ;;
		esac
	    done
	fi
	# now that there is a legitimate setting, ask the user if it is the one desired:
	while 
	    [ $good != "OK" ]
	do
	    msg=$'\nExposure Factor: '
	    echo "$msg" $exp
	    read -p "Is the Exposure Factor correctly specified? [Y or N]: " answer
	    case $answer in
		# if not, prompt and test the entry until it is qualified:
		[nN]* ) read -p "Enter S (sunny-exposed), M (mix sun-shade), or W (well-shaded) only: " exp
			# Make sure it is qualified:
			case $exp in
				[mMsSwW] ) setting="OK" ;;
				* ) setting="notOK" ;;
			esac
			if [ $setting != OK ]
			then	
				while [ $setting != OK ]
				do
					echo ""
					echo "Exposure factor is incorrectly set to" "$exp"
					read -p "Enter S (sunny-exposed), M (mix sun-shade), or W (well-shaded) only: " exp
					case $exp in
						[mMsSwW] ) setting="OK" ;;
						* ) setting="notOK" ;;
					esac
				done
			fi ;;
		[yY]* ) good="OK" ;;
		* ) echo "Y or N only please!" ;;
	    esac
	done
	good="NotOK"
	# Directions
	while [ $good != "OK" ]
	do
	    echo ""
	    read -p "Is there currently a known link to Google map directions? [Y/N]: " answer
	    case $answer in
		[nN]* ) dirs="" 
			dirstest=0
			good="OK" ;;
		[yY]* )	dirstest=1
			good="OK" ;;
		* ) echo "Y or N only please!" ;;
            esac
        done
	if [ $dirstest -gt 0 ] 
	then {
	    good="NotOK"
	    while
		[ $good != "OK" ]
	    do
	    	msg=$'\nGoogle map directions link: '
            	echo "$msg" $dirs
	    	read -p "Is that the correct link? [y/N]: " answer
	    	case $answer in 
	  		[nN]* ) read -p "Enter correct link to Google map directions here: " dirs ;;
			[yY]* ) good="OK" ;;
			* ) echo "Y or N only please!"
	    	esac
	    done
	}
	fi
	good="NotOK"
	# LASTLY, Check Flickr album line
	while
    	    [ $good != "OK" ]
	do
	    msg=$'\nFlickr album link: '
	    echo "$msg" $flnk
	    read -p "Is the Flickr album LINK (URL) correct? [Y or N]: " answer
	    case $answer in
	        [nN]* ) read -p "Enter correct link URL here: " flnk;;
	        [yY]* ) good="OK";;
	        * ) echo "Y or N only please!";;
	    esac
	done
	good="NotOK"
	# translate the Exposure Rating letter into the corresponding icon
	case $exp in
	        [mM] ) expIcon="images/greenshade.jpg"
			expTxt="Partial shade icon" ;;
	        [sS] ) expIcon="images/sun.jpg"
			expTxt="Full sun - exposed icon" ;;
	        [wW] ) expIcon="images/shady.png"
			expTxt="Partial sun/shade icon" ;;
	esac
}
fi
# ----------------------- END OF INPUT DATA TESTING ----------------------

# Now, create the new table entry:
if [ $notindx -gt 0 ] 
then {
	echo "                    <tr>
                        <td>""$city""</td>
                        <td>""$hike""</td>
                        <td>""$wow""</td>
                        <td><a href=\"pages/""$webpg"".html\" target=\"_blank\">
                            <img class=\"webShift\" src=\"images/greencheck.jpg\" alt=\"checkbox\" /></a></td>
                        <td>""$miles"" miles</td>
                        <td>""$elev"" ft</td>
                        <td>""$ease""</td>
                        <td><img class=\"expShift\" src=\""$expIcon"\" alt=\""$expTxt"\" /></td>
                        <td><a href=\""$dirs"\" target=\"_blank\">MapIt!</a></td>
                        <td><a href=\""$flnk"\" target=\"_blank\">
                            <img class=\"flckrShift\" src=\"images/flckr.jpg\" alt=\"Flickr symbol\" /></a></td>
                    </tr>" > newRow
}
else {
# if an index site, some parameters are automatically assigned or empty:
	echo "                    <tr class=\"indxd\">
                        <td>""$city""</td>
                        <td>""$hike""</td>
                        <td>See Indx</td>
                        <td><a href=\"pages/""$webpg"".html\" target=\"_blank\">
                            <img class=\"webShift\" src=\"images/indxCheck.png\" alt=\"checkbox\" /></td>
                        <td>0* miles</td>
                        <td>0* ft</td>
                        <td>See Indx</td>
                        <td>See Indx</td>
                        <td>See Indx</td>
                        <td>See Indx</td>
                    </tr>" > newRow
}
fi
# pull in the index.html file:
# NOTE: the location of this entry depends on hike type!
indxHd=`/usr/bin/awk -v loc="$hikeType" '
BEGIN {
	located=0
}
{
	if( loc == "V" ) {
		#Find the end of the indexed hikes in the table
		if ( located == 0 ) {
			if ( match($0,/<tr class=\"indxd\">/) ) {
				while ( located == 0 ) {
					getline
					if( match($0,/<tr>/) ) {
						located = 1
						indxEnd=NR
						indxEnd=NR-1
						print indxEnd
						break
					}
				}
			}
		}
	}
	else {
		#Get the end of the table, marked by the </tbody> tag:
		if( match($0,/<\/tbody>/) ) {
       		 	eotbl=NR
       		       	eotbl=eotbl-1
       	        	print eotbl
       		 }

	}
}'  "$indxLoc"`
head -n "$indxHd" "$indxLoc" > IndxHead.html
indxLines=`cat "$indxLoc" | wc -l`
indxTl=$(( $indxLines - $indxHd ))
tail -n "$indxTl" "$indxLoc" > IndxTail.html
cat newRow >> IndxHead.html
rm newRow
cat IndxTail.html >> IndxHead.html
mv IndxHead.html newindex.html
rm IndxTail.html
echo "
The following data will be added:"
if [ $notindx -gt 0 ]
then
diff newindex.html "$indxLoc" | tail -14
else
diff newindex.html "$indxLoc" | tail -13
fi
good="NotOK"
while
        [ $good != "OK" ]
do
	read -p "Do you wish to permanently save these changes in $indxLoc [Y/N]? " ans
	case $ans in
	    [nN]* ) echo "$indxLoc unchanged; Changes reside in newindex.html"
		    good="OK" ;;
	    [yY]* ) echo "$indxLoc has been re-written with new row data"
		    mv newindex.html "$indxLoc"
		    good="OK";;
	    * ) echo "Y or N only please!";;
	esac
done
# NOW - modify the map.js file accordingly
# Test for existence of map.js:
echo "

"
if [ -f $mapjsLoc ]
then
        echo "using" "$mapjsLoc" "as basis for potential modification..."
else
        echo "map.js file not found at" "$indxLoc"
        exit
fi
echo ""
echo "The file:" "$mapjsLoc" "will be modified (if user opts) to add a marker to the map"
echo ""
#Find the line number to start adding the new marker data
mapjsHd=`/usr/bin/awk -v MArray=$hikeAR '
BEGIN {
	foundArray=0
}
{
	if( match($0,MArray) ) {
		# just look for the first occurrance...
		foundArray=1
	} else {
		if( foundArray == 1 ) {
			if( match($0,/];/) ) {
				eoArray=NR
				eoArray=eoArray-1
				print eoArray
				exit(4)
			}
		}
	}
}' $mapjsLoc`
head -n "$mapjsHd" "$mapjsLoc" > newmap.js
if [ hikeType == "H" ]
then {
	sed -i.bck '$s/$/,/' newmap.js
	rm newmap.js.bck
}
else {
	sed -i.bck '$s/$/,/' newmap.js
	rm newmap.js.bck
}
fi
mapLgth=`cat "$mapjsLoc" | wc -l`
tailCnt=$(( $mapLgth - $mapjsHd ))
#tailCnt=$(( $tailCnt + 1 ))
tail -n "$tailCnt" "$mapjsLoc" > maptail.js
read -p "Please enter the latitude for this marker: " lat
good="NotOK"
while 
	[ $good != "OK" ]
do
	msg=$'\nYou entered a latitude of '
	echo "$msg""$lat"
        read -p "Is the latitude Correct? [Y or N]: " answer
        case $answer in
                [nN]* ) read -p "Enter correct latitude here: " lat ;;
                [yY]* ) good="OK";;
                * ) echo "Y or N only please!";;
        esac
done
read -p "Please enter the longitude for this marker (negative number): " lng
good="NotOK"
while
        [ $good != "OK" ]
do
        msg=$'\nYou entered a longitude of '
        echo "$msg""$lng"
        read -p "Is the longitude Correct? [Y or N]: " answer
        case $answer in
                [nN]* ) read -p "Enter correct longitude here: " lng ;;
                [yY]* ) good="OK";;
                * ) echo "Y or N only please!";;
        esac
done
if [ $hikeType != "V" ]
then {
	good="NotOK"

	while
		[ $good != "OK" ]
	do
	    read -p "Is there a json (GPX) track file for this hike? [Y or N]: " answer
	    case $answer in
		[nN]* ) trackPres=0
			json=""
			trkclr="noTrk"
			good="OK" ;;
		[yY]* ) trackPres=1
			read -p "Enter the json filename (with extension: must reside in json dir: " json
			good="OK" ;;
		* ) echo "Y or N only please!" ;;
	    esac
	done
	if [ $trackPres -gt 0 ]
	then {
		good="NotOK"
		trkclr="trackColor"
		while
			[ $good != "OK" ]
		do
			msg=$'\nYou entered a json filename of: '
			echo "$msg" "$json"
			read -p "Is the filename correct? [Y/N]: " answer
			case $answer in 
			    [nN]* ) read -p "Enter correct filename here (with extension): " json ;;
			    [yY]* ) good="OK" ;;
			    * ) echo "Y or N only please!" ;;
			esac
		done
	}
	fi
}
fi
if [ $hikeType == "C" ]
then {
	echo "        ['""$hike""',""$lat"",""$lng"",'""$webpg"".html','""$json""',""$trkclr""]" > latlng
}
else {
	if [ $hikeType == "H" ]
	then {
		echo "        ['""$hike""',""$lat"",""$lng"",'""$webpg"".html','""$json""']" > latlng
	}
	else {
		echo "        ['""$hike""',""$lat"",""$lng"",'""$webpg"".html','']" > latlng
	}
	fi
}
fi
cat latlng >> newmap.js
rm latlng
cat maptail.js >> newmap.js
rm maptail.js
echo "Here are the potential changes for the map.js file:"
echo "NOTE: < changes listed first, > current map.js file second"
diff newmap.js "$mapjsLoc"
good="NotOK"
while
        [ $good != "OK" ]
do
        read -p "Do you wish to permanently save these changes in $mapjsLoc [Y/N]? " ans
        case $ans in
            [nN]* ) echo "$mapjsLoc unchanged; Changes reside in newmap.js"
                    good="OK" ;;
            [yY]* ) echo "$mapjsLoc has been re-written with new marker data"
                    mv newmap.js "$mapjsLoc"
                    good="OK";;
            * ) echo "Y or N only please!";;
        esac
done
echo "DONE!"

