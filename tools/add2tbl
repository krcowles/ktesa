#!/bin/bash
# VERSION 8: modified to conform to new (data directory) index table location and format
MAPFILE=0
# file locations usedn script: -T Tom, will supply his via prompt
TOM=0
indxLoc="/Users/kencowles/src/ktesa/data/hikeDataTbl.html"
mapjsLoc="/Users/kencowles/src/ktesa/data/hikeArrays.js" 
geomapLoc="/Users/kencowles/src/ktesa/maps/"
jsonLoc="/Users/kencowles/src/ktesa/json/"
#
# ------------------------ COMMAND LINE PROCESSING & HELP INFO ---------------------
for i
do
#	-m: get geomap name
	if [ $MAPFILE -eq 1 ]
	then {
		mapfile=$i
		mapreqd=1
		MAPFILE=2
	}
	fi
        # find flags:
        case $i in
	-T) read -p "TOM: Specify your project directory, ending with \"ktesa/\" : " tom
	    TOM=1 ;;
	-m) MAPFILE=1 ;;
	-h) echo "
*** Version 8
Updated to load index from data directory and conform to new format
"
# OLD VERSION HEADERS:
#*** Version 7
#Updated to add increased number of data elements per row of table in index.html
#and added updates to map.js to accommodate marker and track creation
#*** Version 6
#Compatible with new Google Map index page; potentially modifies both index.html and map.js
#User can choose not to modify, but independently save local copies of modified files.
#*** Version 5
#Added checking of map file to ensure Google API key is present
#*** Version 4.1
#Rewritten to accommodate icon-based index table
#[4.1: added local check for FlckrAlbumURL created by mkgpsv]
# *** Version 3.0
# Added prompt to identify expected exposure 
# *** Version 2.0
# Added prompt to locate region of NM Map in which hike occurred
# *** Version 1.0
	echo "
This utility will prompt the user for input to create a new row in the
table of \"hikeDataTbl.html\", and to modify the corresponding hikeArrays.js file 
for creation of markers and tracks.

Inputs will be verified by the user before creating the html,
or modifying the hikeArray.js file.

TOM: Use -T flag (no arg) so that you can specify the correct filepaths to the files
(the routine will prompt you)

Use the -m flag to specify the NAME ONLY of the geomap: it is assumed that the location
of the geomap is /Users/kencowles/src/ktesa/maps, or as specified by TOM.
If there is no geomap (ie no -m flag), the routine will check for one, and ask if 
a geomap is being used for this hike page.
    Example using flag: add2indx  -m example_geomap_no_lists.html

The user will have the opportunity to over-write the hikeDataTbl.html file, or save only
the local copy, \"newindex.html\" if review is desired before over-writing.
The user similarly will have the opportunity to over-write the hikeArrays.js file, or 
save only a local copy, \"newarray.js\".

"
	exit;;
        esac
done
if [ $TOM -gt 0 ]
then {
	indxLoc="${tom}data/hikeDataTbl.html"
	mapjsLoc="${tom}data/hikeArrays.js"
	geomapLoc="${tom}maps/"
	jsonLoc="${tom}json/"
}
fi
# --- END COMMAND LINE / HELP
#
# ------------------------ GOOGLE MAP API KEY CHECKING / INSERTION ---------------------
if [ $MAPFILE -eq 0 ]
then {
	mapreqd=1
	good="NotOK"
	while
		[ $good != "OK" ]
	do
		echo ""
		echo "Map file not specified:"
        	read -p "Is geomap included with this web page? " map
        	case $map in
                	[nN]* ) echo "*** Google API Key not required"
				mapreqd=0
				good="OK" ;;
                	[yY]* ) echo "Google API Key is required;"
				read -p "please specify geomap name (no path): " mapfile
				good="OK" ;;
                	* ) echo "Y or N only please!";;
        	esac
	done
}
fi
if [ $mapreqd -gt 0 ]
# assert validity of geomap name
then {
        good="NotOK"
        while
	        [ $good != "OK" ]
        do
            msg=$'\nGeomap name (including file extension): '
            echo "$msg" "$mapfile"
            read -p "Is the geomap filename Correct? [Y or N]: " answer
            case $answer in
                [nN]* ) read -p "Enter correct geomap filename here: " mapfile;;
                [yY]* ) good="OK";;
                * ) echo "Y or N only please!";;
            esac
        done
	mapLoc="$geomapLoc""$mapfile"
	echo ""
	if [ -f $mapLoc ] 
	then {
		echo "File located"
		echo ""
	}
	else {
		echo "geomap file not located"
		exit
	}
	fi
	echo "The map at "${mapLoc}" will be checked for existence of the Google API Key;
    -if not present, the key will be inserted;
    You will have the opportunity to accept the change or not"
	# now process the map for the Google API Key:
	/usr/bin/awk -v sq="'" '
	{
		if( match($0,/google_api_key = /) ) {
			APIloc=index($0,"google_api_key = ") +17
			currVal=substr($0,APIloc,2)
			newStr=substr($0,1,APIloc)
			strLgth=length - APIloc
			remains=substr($0,APIloc+2,strLgth)
			key="AIzaSyA2Guo3uZxkNdAQZgWS43RO_xUsKk1gJpU"sq
			if( currVal == sq"A" ) {
				print "YOWZAH"
			}
			else {
				print newStr key remains
			}
		} else {
			print $0
		}
	}' $mapLoc > zool
	chg=`grep YOWZAH zool | wc -l`
	if [ $chg -eq 0 ] 
	then {
		good="NotOK"
		echo ""
		read -p "** API key not detected in map; Do you wish to overwrite "${mapfile}" with key? [Y/N]: " answer
		while
		        [ $good != "OK" ]
		do
		        case $answer in
		                [nN]* ) echo "No changes made" 
					good="OK" ;;
		                [yY]* ) mv zool $mapLoc
					echo "Map ["${mapfile}"] updated"
					good="OK";;
		                * ) echo "Y or N only please!";;
		        esac
		done
	}
	else {
		echo "** Key already present - nothing modified"
		rm zool
	}
	fi
}
fi
echo ""
# --- END OF API KEY CHECK
#
# -------------------------- READING IN REQUIRED INFO FOR HIKE DATA TABLE ---------------------
# Test for existence of hikeDataTbl.html for the path:
if [ -f $indxLoc ] 
then
	echo "using" "$indxLoc" "as basis for potential modification..."
else
	echo "hikeDataTbl.html file not found at" "$indxLoc"
	exit
fi
echo "The file:" "$indxLoc" "will be modified (if user opts) to add a row to the table"
fext=.html
echo ""
# in order to properly create the markers & tracks in the js file, this utility needs to know
# what "type" the hike is, as below:
echo "This routine needs to know what kind of hike to specify:
     Type \"V\" for Park Visitor Center-based marker (i.e. index page);
     Type \"C\" for cluster hike - i.e. trailhead in very close proximity to another, or overlapping;
     Type \"H\" for \"normal\" hike - i.e. none of the above types.
"
good="NotOK"
while
        [ $good != "OK" ]
do
	read -p "Enter single letter here: " hikeType
	case $hikeType in
		[vV] ) good="OK" ;;
		[cC] ) good="OK" ;;
		[hH] ) good="OK" ;;
		* )    echo "Unrecognized hike type:"
		       echo "" ;;
	esac
done
echo "Hike type is ${hikeType}"
notindx=1
case $hikeType in
        [vV] ) hikeType="V"
	       hikeAR="ctrPinHikes"
	       echo "setting notindx=0"
	       notindx=0 ;;
        [cC] ) hikeType="C"
	       hikeAR="clusterPinHikes" ;;
        [hH] ) hikeType="H"
	       hikeAR="othrHikes" ;;
esac
if [ $hikeType == "C" ]
#
# ------------------------- CLUSTERED HIKES REQUIRE EXTRA INFO -------------------------
# --- First, determine the "data-cluster" group assignment:
then {
	echo ""
	# Get the last letter currently used in the "data-cluster" assignments:
	lastClus=`cat "$indxLoc" | grep "clustered" | tail -1`
        export lastClus
        # first cut eliminates variable lead-in tabs/spaces
        lastletter=`echo $lastClus | cut -f3 -d" " | cut -c15`
        echo "Last cluster group letter is ${lastletter}"
	echo
        export lastletter
	# determine the next letter in sequence:
        dval=`printf '%d' "'$lastletter"`
        dval=$(( $dval + 1 ))
        nxtc=`/usr/bin/awk -v num=$dval 'BEGIN{printf "%c", num}'`
	good="NotOK"
	while
       	 [ $good != "OK" ]
	do
	    read -p "Does this hike begin a new cluster (overlapping trailhead)? [Y/N]: " ans
	    case $ans in
	        [nN]* ) newClus=0
			good="OK" ;;
	        [yY]* ) newClus=1
			good="OK";;
	        * ) echo "Y or N only please!";;
	    esac
	done
	if [ $newClus -gt 0 ] 
	then {
		echo "
     **** New clusters will require altering of the hikeArrays.js AND hikeDataTbl.html
     files to move the related hikes to the new cluster, and be re-assigned as cluster hikes!
"
		good="notOK"
		while [ $good != "OK" ]
		do
			read -p "Do you wish to use the next letter in sequence [${nxtc}] for the new cluster group? [Y/N]: " ans
			case $ans in 
				[yY]* ) newval="${nxtc}"
					good="OK" ;;
				[nN]* ) read -p "Specify desired cluster-group letter here: " newval
					if [ ${#newval} -gt 1 ]
					then
						read -p "Too many characters: try again: " newval
					fi
					echo "You selected ${newval}"
					good="OK" ;;
				* ) echo "Only Y or N please!" ;;
			esac
		done
	}
	else {
		good="notOK"
		while [ $good != "OK" ]
		do
			read -p "Please specify the cluster-group with which this hike is to be associated: " newval
			if [ ${#newval} -gt 1 ] 
			then
				read -p "Too many characters - single letter only: " newval
			else {
				tstd=`printf '%d' "'$newval"`
				#dec "A" is 65
				if [ $tstd -ge 65 ] && [ $tstd -lt $dval ]
				then
					good="OK"
				else
					echo "This letter group [${newval}] is not in the correct range [A-${lastletter}]"
				fi
			}
			fi
		done
	}
	fi
	good="notOK"
	while [ $good != "OK" ]
	do
		read -p "Do you wish to assign a track color other than the default (red)? [Y/N] :" ans
		case $ans in 
			[nN]* ) trkcol="R"
			        good="OK" ;;
			[yY]* ) read -p "Enter the capitalized letter for the track color of choice [R-ed,B-lue,G-reen,blac-K]: " trkcol
				echo "[Unrecognized responses will default to Red]"
				good="OK" ;;
			* ) 	echo "Y or N only please!" ;;
		esac
	done
	case $trkcol in
		[bB] ) trkdes="altTrkClr1" ;;
		[gG] ) trkdes="altTrkClr2" ;;
		[kK] ) trkdes="altTrkClr3" ;;
		* ) trkdes = "trackColor" ;;
	esac
}
fi
# --- END CLUSTER GROUP ASSIGNMENT
# 
# ------------------------ COLLECT USER INPUT DATA ON HIKE ----------------------
if [ $notindx -eq 0 ]
then {
	echo "The following parameters will be pre-assigned:"
	echo "    WOW Factor: See Indx"
        echo "    Distance: 0* miles"
        echo "    Elevation: 0* ft"
        echo "    Difficulty: See Indx"
        echo "    Exposure: See Indx"
	echo "    Google Directions: See Indx"
        echo "    Flickr album entry: See Indx"
        echo "Row class will be \"indxd\""
}
fi
echo ""
read -p "Enter the name of the hike location (nearest city): " city
read -p "Enter hike name [Append with \"Index\" for Index pages]: " hike
read -p "Enter hike page (or index site) base filename [* Assumed to be in project pages dir with .html extension]: " webpg
if [ $notindx -gt 0 ]
then {
	dirs=""
	read -p "Enter WOW Factor: " wow
	read -p "Enter hike distance (round trip) in miles: " miles
	read -p "Enter hike elevation max in feet: " elev
	read -p "Enter hike difficulty: " ease
	read -p "Enter S (sunny-exposed), M (mix sun-shade), or W (well-shaded): " exp
	read -p "Enter Google Map Directions link, if known (otherwise hit RETURN): " dirs
	if [ -f FlckrAlbumURL ] 
	then
		flnk=`cat FlckrAlbumURL`
	else
		read -p "Enter hike Flickr album link (url): " flnk
	fi
}
fi
# --- END INPUT GATHERING FOR DATA TABLE
echo ""
echo "*** Check the data for accuracy before proceeding ***"
# -------------------------- FUNCTION TO PROCESS INPUT TESTING -------------------------
input_test() {
good="notOK"
while [ $good != "OK" ]
do
	msg=$'\n${1}: '
	echo "$msg" "$2"
	read -p "Is the ${1} correct? [Y/N]: " ans
	case $ans in
		[nN]* ) echo "Enter new ${1} here: " out ;;
		[yY]* ) out=$2
			good="OK" ;;
		* )     echo "Y or N only please!" ;;
	esac
done
return out
}
# ----------------------------- TEST THE INPUT DATA --------------------------------
#newcity=input_test "Location" $city
#echo "TEST FUNCTION: " "$newcity"
good="NotOK"
while
	[ $good != "OK" ]
do
    msg=$'\nLocation: '
    echo "$msg" $city
    read -p "Is the location Correct? [Y or N]: " answer
    case $answer in
	[nN]* ) read -p "Enter correct location here: " city;;
	[yY]* ) good="OK";;
	* ) echo "Y or N only please!";;
    esac
done
good="NotOK"
while
        [ $good != "OK" ]
do
    msg=$'\nHike Name: '
    echo "$msg" $hike
    read -p "Is the hike name correct? [Y or N]: " answer
    case $answer in
        [nN]* ) read -p "Enter correct hike name here: " hike;;
        [yY]* ) good="OK";;
        * ) echo "Y or N only please!";;
    esac
done
good="NotOK"
while
	[ $good != "OK" ]
do
	msg=$'\nWeb page for hike (or index): pages/'
	echo "$msg"$webpg".html"
	read -p "Is this the correct webpage html file? [Y or N]: " answer
	case $answer in
	    [nN]* ) read -p "Enter correct web page base name [* Assumed to be in project pages dir with .html extension]: " webpg ;;
	    [yY]* ) good="OK" ;;
	    * ) echo "Y or N only please!" ;;
	esac
done
# if the entry is not an index site, prompt for the distance, elevation, ease of hike::
if [ $notindx -gt 0 ]
then {
	# WOW FACTOR:
	good="NotOK"
	while
       		 [ $good != "OK" ]
	do
    		msg=$'\nWow Factor: '
    		echo "$msg" $wow
   		read -p "Is the specified WOW Factor correct? [Y/N]: " answer
    		case $answer in
        		[nN]* ) read -p "Enter correct WOW Factor here: " wow ;;
        		[yY]* ) good="OK" ;;
        		* ) echo "Y or N only pleas!" ;;
    		esac
	done
	# DISTANCE:
	good="NotOK"
	while
	        [ $good != "OK" ]
	do
	    msg=$'\nDistance (miles): '
	    echo "$msg" $miles
	    read -p "Is the distance in miles correct? [Y or N]: " answer
	    case $answer in
	        [nN]* ) read -p "Enter correct distance here (miles): " miles;;
	        [yY]* ) good="OK";;
	        * ) echo "Y or N only please!";;
	    esac
	done
	good="NotOK"
	# ELEVATION:
	while
       	 [ $good != "OK" ]
	do
	    msg=$'\nElevation (feet): '
	    echo "$msg" $elev
	    read -p "Is the elevation in feet correct? [Y or N]: " answer
	    case $answer in
	        [nN]* ) read -p "Enter correct elevation in feet here: " elev;;
	        [yY]* ) good="OK";;
	        * ) echo "Y or N only please!";;
	    esac
	done
	good="NotOK"
	# EASE OF HIKE:
	while
       	 [ $good != "OK" ]
	do
	    msg=$'\nEase of hike: '
	    echo "$msg" $ease
	    read -p "Is the ease-of-hike rating correct? [Y or N]: " answer
	    case $answer in
	        [nN]* ) read -p "Enter correct ease-of-hike rating here: " ease;;
	        [yY]* ) good="OK";;
	        * ) echo "Y or N only please!";;
	    esac
	done
	good="NotOK"
	# EXPOSURE RATING:
	# FIRST: check exposure rating;
	case $exp in
	    [mMsSwW] ) setting="OK" ;;
	    * ) setting="notOK" ;;
	esac
	# if the setting was incorrect to begin with, get a legitimate one:
	if [ $setting != OK ]
	then
	    while [ $setting != OK ]
	    do
		echo ""
	        echo "Exposure factor is incorrectly set to" "$exp"
	        read -p "Enter S (sunny-exposed), M (mix sun-shade), or W (well-shaded) only: " exp
		case $exp in
		    [mMsSwW] ) setting="OK" ;;
		    * )  setting="notOK" ;;
		esac
	    done
	fi
	# now that there is a legitimate setting, ask the user if it is the one desired:
	while 
	    [ $good != "OK" ]
	do
	    msg=$'\nExposure Factor: '
	    echo "$msg" $exp
	    read -p "Is the Exposure Factor correctly specified? [Y or N]: " answer
	    case $answer in
		# if not, prompt and test the entry until it is qualified:
		[nN]* ) read -p "Enter S (sunny-exposed), M (mix sun-shade), or W (well-shaded) only: " exp
			# Make sure it is qualified:
			case $exp in
				[mMsSwW] ) setting="OK" ;;
				* ) setting="notOK" ;;
			esac
			if [ $setting != OK ]
			then	
				while [ $setting != OK ]
				do
					echo ""
					echo "Exposure factor is incorrectly set to" "$exp"
					read -p "Enter S (sunny-exposed), M (mix sun-shade), or W (well-shaded) only: " exp
					case $exp in
						[mMsSwW] ) setting="OK" ;;
						* ) setting="notOK" ;;
					esac
				done
			fi ;;
		[yY]* ) good="OK" ;;
		* ) echo "Y or N only please!" ;;
	    esac
	done
	good="NotOK"
	# Directions
	while [ $good != "OK" ]
	do
	    echo ""
	    read -p "Is there currently a known link to Google map directions? [Y/N]: " answer
	    case $answer in
		[nN]* ) dirs="" 
			dirstest=0
			good="OK" ;;
		[yY]* )	dirstest=1
			good="OK" ;;
		* ) echo "Y or N only please!" ;;
            esac
        done
	if [ $dirstest -gt 0 ] 
	then {
	    good="NotOK"
	    while
		[ $good != "OK" ]
	    do
	    	msg=$'\nGoogle map directions link: '
            	echo "$msg" $dirs
	    	read -p "Is that the correct link? [y/N]: " answer
	    	case $answer in 
	  		[nN]* ) read -p "Enter correct link to Google map directions here: " dirs ;;
			[yY]* ) good="OK" ;;
			* ) echo "Y or N only please!"
	    	esac
	    done
	}
	fi
	good="NotOK"
	# LASTLY, Check Flickr album line
	while
    	    [ $good != "OK" ]
	do
	    msg=$'\nFlickr album link: '
	    echo "$msg" $flnk
	    read -p "Is the Flickr album LINK (URL) correct? [Y or N]: " answer
	    case $answer in
	        [nN]* ) read -p "Enter correct link URL here: " flnk;;
	        [yY]* ) good="OK";;
	        * ) echo "Y or N only please!";;
	    esac
	done
	good="NotOK"
	# translate the Exposure Rating letter into the corresponding icon
	case $exp in
	        [mM] ) expIcon="../images/greenshade.jpg"
			expTxt="Partial shade icon" ;;
	        [sS] ) expIcon="../images/sun.jpg"
			expTxt="Full sun - exposed icon" ;;
	        [wW] ) expIcon="../images/shady.png"
			expTxt="Partial sun/shade icon" ;;
	esac
}
fi
# --- END OF INPUT DATA TESTING
#
# ---------------------------------- CREATE THE TABLE ENTRIES ---------------------------
# Basic data entry will reside in "newRow"
if [ $notindx -gt 0 ] 
then {
	if [ $hikeType == "C" ]
	then
		echo "        <tr class=\"clustered\" data-cluster=\"${newval}\">" > newRow
	else 
		echo "        <tr>" > newRow
	fi
	echo "            <td>""$city""</td>
            <td>""$hike""</td>
            <td>""$wow""</td>
            <td><a href=\"${webpg}.html\" target=\"_blank\">
                <img class=\"webShift\" src=\"../images/greencheck.jpg\" alt=\"checkbox\" /></a></td>
            <td>""$miles"" miles</td>
            <td>""$elev"" ft</td>
            <td>""$ease""</td>
            <td><img class=\"expShift\" src=\"${expIcon}\" alt=\""$expTxt"\" /></td>
            <td style=\"text-align:center\"><a href=\""$dirs"\" target=\"_blank\"><img src=\"../images/dirs.png\" alt=\"google driving directions\" /></a></td>
            <td><a href=\""$flnk"\" target=\"_blank\">
                <img class=\"flckrShift\" src=\"../images/album_lnk.png\" alt=\"Flickr symbol\" /></a></td>
        </tr>" >> newRow
}
else {
# if an index site, some parameters are automatically assigned or empty:
	echo "        <tr class=\"indxd\">
            <td>""$city""</td>
            <td>""$hike""</td>
            <td>See Indx</td>
            <td><a href=\"pages/""$webpg"".html\" target=\"_blank\">
                <img class=\"webShift\" src=\"images/indxCheck.png\" alt=\"checkbox\" /></td>
            <td>0* miles</td>
            <td>0* ft</td>
            <td>See Indx</td>
            <td>See Indx</td>
            <td>See Indx</td>
            <td>See Indx</td>
        </tr>" > newRow
}
fi
# ------------------ LOCATE THE PLACE IN THE TABLE WHERE THE DATA WILL RESIDE ---------------
# NOTE:
#	Indexed hikes are located at the top of the table
#	Clustered Hikes are immediately after Indexed hikes
#	Other Hikes follow the above
#   var indxHd is assigned the Line Number in the table where data will be inserted
indxHd=`/usr/bin/awk -v loc="$hikeType" '
BEGIN {
	located=0
}
{
	if( loc == "V" ) {
		#Find the end of the indexed hikes in the table
		if ( located == 0 ) {
			if ( match($0,/<tr class=\"indxd\"/) ) {
				while ( located == 0 ) {
					getline
					if( match($0,/<tr class=\"clustered\"/) ) {
						located = 1
						indxEnd=NR-1
						print indxEnd
						break
					}
				}
			}
		}
	}
	else if( loc == "C" ) {
		#Find the end of the clustered hikes in the table
		if (located == 0 ) {
			if ( match($0,/<tr class=\"clustered\"/) ) {
				while ( located == 0 ) {
					getline
					if ( match($0,/<tr>/) ) {
						located = 1
						indxEnd = NR-1
						print indxEnd
						break
					}
				}
			}
		}
	} else {
		#Get the end of the table, marked by the </tbody> tag:
		if( match($0,/<\/tbody>/) ) {
       		 	eotbl=NR-1
       	       	print eotbl
     	}
	}
}'  "$indxLoc"`
# --- END OF LOCATING INSERTION POINT
#
# ---------------------  CONSTRUCT NEW TABLE (BUT DON'T OVERWRITE ------------------
head -n "$indxHd" "$indxLoc" > IndxHead.html
indxLines=`cat "$indxLoc" | wc -l`
indxTl=$(( $indxLines - $indxHd ))
tail -n "$indxTl" "$indxLoc" > IndxTail.html
cat newRow >> IndxHead.html
rm newRow
cat IndxTail.html >> IndxHead.html
mv IndxHead.html newindex.html
rm IndxTail.html
echo "
The following data will be added:"
if [ $notindx -gt 0 ]
then
diff newindex.html "$indxLoc" | tail -14
else
diff newindex.html "$indxLoc" | tail -13
fi
# --- END OF TABLE CREATION
#
# --------- DOES USER WISH TO OVERWRITE HIKE DATA TABLE OR KEEP A SEPARATE FILE? ---------
good="NotOK"
while
        [ $good != "OK" ]
do
	read -p "Do you wish to permanently save these changes in $indxLoc [Y/N]? " ans
	case $ans in
	    [nN]* ) echo "$indxLoc unchanged; Changes reside in newindex.html"
		    good="OK" ;;
	    [yY]* ) echo "$indxLoc has been re-written with new row data"
		    mv newindex.html "$indxLoc"
		    good="OK";;
	    * ) echo "Y or N only please!";;
	esac
done
# --- DONE PROMPTING USER FOR CHOICE
#
# ------------------- PREPARE HIKEARRAY.JS FOR DATA INSERTION -------------------
# Test for existence of hikeArrays.js:
echo "

"
if [ -f $mapjsLoc ]
then
        echo "using" "$mapjsLoc" "as basis for potential modification..."
else
        echo "map.js file not found at" "$indxLoc"
        exit
fi
echo ""
echo "The file:" "$mapjsLoc" "will be modified (if user opts) to add a marker to the map"
echo ""
# the line number for inserting data will be held in "mapjsHd"
mapjsHd=`/usr/bin/awk -v MArray=$hikeAR '
BEGIN {
	foundArray=0
}
{
	if( match($0,MArray) ) {
		# just look for the first occurrance...
		foundArray=1
	} else {
		if( foundArray == 1 ) {
			if( match($0,/];/) ) {
				eoArray=NR-1
				print eoArray
				exit(4)
			}
		}
	}
}' $mapjsLoc`
head -n "$mapjsHd" "$mapjsLoc" > newarray.js
# former last array element needs comma before adding next array
sed -i.bck '$s/$/,/' newarray.js
rm newarray.js.bck
mapLgth=`cat "$mapjsLoc" | wc -l`
tailCnt=$(( $mapLgth - $mapjsHd + 1 )) 
tail -n "$tailCnt" "$mapjsLoc" > maptail.js
# --- END OF PREP
#
# ----------------------------- PROMPT USER FOR DATA ---------------------------
read -p "Please enter the latitude for this marker: " lat
good="NotOK"
while 
	[ $good != "OK" ]
do
	msg=$'\nYou entered a latitude of '
	echo "$msg""$lat"
        read -p "Is the latitude Correct? [Y or N]: " answer
        case $answer in
                [nN]* ) read -p "Enter correct latitude here: " lat ;;
                [yY]* ) good="OK";;
                * ) echo "Y or N only please!";;
        esac
done
read -p "Please enter the longitude for this marker (negative number): " lng
good="NotOK"
while
        [ $good != "OK" ]
do
        msg=$'\nYou entered a longitude of '
        echo "$msg""$lng"
        read -p "Is the longitude Correct? [Y or N]: " answer
        case $answer in
                [nN]* ) read -p "Enter correct longitude here: " lng ;;
                [yY]* ) good="OK";;
                * ) echo "Y or N only please!";;
        esac
done
if [ $hikeType != "V" ]
then {
	good="NotOK"
	while
		[ $good != "OK" ]
	do
	    read -p "Is there a json (GPX) track file for this hike? [Y or N]: " answer
	    case $answer in
		[nN]* ) trackPres=0
			json=""
			trkclr="noTrk"
			good="OK" ;;
		[yY]* ) trackPres=1
			read -p "Enter the json filename (with extension: must reside in json dir: " json
			good="OK" ;;
		* ) echo "Y or N only please!" ;;
	    esac
	done
	if [ $trackPres -gt 0 ]
	then {
		good="NotOK"
		trkclr="trackColor"
		while
			[ $good != "OK" ]
		do
			msg=$'\nYou entered a json filename of: '
			echo "$msg" "$json"
			read -p "Is the filename correct? [Y/N]: " answer
			case $answer in 
			    [nN]* ) read -p "Enter correct filename here (with extension): " json ;;
			    [yY]* ) good="OK" ;;
			    * ) echo "Y or N only please!" ;;
			esac
		done
	}
	fi
}
fi
# --- END OF DATA ACQUISITION
#
# ----------------------- CREATE DATA FOR NEW ELEMENT -----------------------
if [ $hikeType == "C" ]
then {
	echo "    ['""$hike""',""$lat"",""$lng"",'""$webpg"".html','""$json""',""$trkdes"",0]" > latlng
}
else {
	if [ $hikeType == "H" ]
	then {
		echo "    ['""$hike""',""$lat"",""$lng"",'""$webpg"".html','""$json""']" > latlng
	}
	else {
		echo "    ['""$hike""',""$lat"",""$lng"",'""$webpg"".html','']" > latlng
	}
	fi
}
fi
cat latlng >> newarray.js
rm latlng
cat maptail.js >> newarray.js
rm maptail.js
# --- END DATA CREATION
# 
# ----------------------- OVERWIRTE FILE OR KEEP A SEPARATE COPY? ------------------
echo "Here are the potential changes for the map.js file:"
echo "NOTE: < changes listed first, > current map.js file second"
diff newarray.js "$mapjsLoc"
good="NotOK"
while
        [ $good != "OK" ]
do
        read -p "Do you wish to permanently save these changes in $mapjsLoc [Y/N]? " ans
        case $ans in
            [nN]* ) echo "$mapjsLoc unchanged; Changes reside in newarray.js"
                    good="OK" ;;
            [yY]* ) echo "$mapjsLoc has been re-written with new marker data"
                    mv newarray.js "$mapjsLoc"
                    good="OK";;
            * ) echo "Y or N only please!";;
        esac
done
echo "DONE!"

